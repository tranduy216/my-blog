---
title: IO Blocking and Non-Blocking IO
date: Feburary 20, 2024
---

## 1. Câu chuyện thực tế
- 1 nhà hàng có 4 đầu bếp
- Cần làm tổng cộng 40 con gà quay
- Gà quay gồm các bước: Ướp gà(5min), chờ gia vị thấm (15min), quay gà (30min), bày biện(10min)


## 2. Blocking IO model
### 2.1 Tại sao tiến trình bị nghẽn, chậm
- 1 đầu bếp sau khi ướp gà, anh ấy lướt web (idle) 15min để gia vị thấm, rồi đi vệ sinh 30min để lò quay, rồi cuối cùng mới lấy gà ra dĩa và trang trí
- Tổng thời gian hoàn thành 1 con gà là 60 phút
- 4 đầu bếp là được 4 con gà trong 60 phút. Vậy cần 600 phút - 10 tiếng để hoàn thành 40 con.
--> Các đầu bếp không làm các việc khác trong thời gian rảnh idle. Số lượng gà tối đa có thể làm chỉ có thể bằng số lượng đầu bếp

### 2.2 Sự tương đồng trong web application truyền thống
- Cơ chế ở trên giống như servlet trong các Java web container hồi xưa, số lượng connection/resquest tối đa mà web container (Tomcat) có thể phục vụ (serve) bầng số lượng thread tối đa của web container đó.
- Dù CPU rất thấp, nhưng việc chờ resource bên ngoài (gia vị thấm, lò quay xong) mà không quay lại thread pool, khiến lượng thread khả dụng không đủ để phục vụ các request khác.

## 3. Non-blocking IO model
### 3.1 Tận dụng thời gian rảnh
- 1 đầu bếp sau khi ướp gà xong mất 5 phút, anh ấy đặt đồng hồ đếm ngược 15min, và ướp thêm được 3 con gà nữa
- Hết 15min tiếp theo, đồng hồ reo, nhét con gà đầu tiên vào lò. Vậy sau 20 phút: 3 con gà ướp xong (mỗi con cách nhau 5 phút), 1 con đang nướng.
- Trong khi chờ lò quay 30min tiếp theo, anh ấy ướp thêm dc 6 con gà nữa, rồi đưa chúng vào lò.
- Vậy sau 50min: Toàn bộ gà đã được ướp. Một số con trong lò đang quay.
- Giả sử lò có thể nướng một lần 40 con gà. Vậy thì ko có việc phải chờ gà trong lò quay xong mới nhét con gà kế tiếp
- 50 min toàn bộ gà ướp xong, giả sử con gà cuối đợi 15min thấm gia vị, 30min quay, 10 min trình bày --> Tổng thời gian: 50 + 15 + 30  + 10 = 105 phút.
- 1 đầu bếp hoàn thành 10 con trong khoảng 105 phút. 4 người làm 40 con cũng cùng thời gian ấy. Tốc độ tăng lên khoảng 7 lần.

### 3.2 Non-blocking IO styles
#### 3.2.1 Điểm chung
- Tận dụng tối đa thread, không có thời gian IDLE, mỗi khi chờ dữ liệu IO từ bên ngoài thì sẽ quay về pool
- Chia tách mục đích xử lý công việc: Việc nhẹ nhanh thì cho event loop threads làm, việc nặng thì dùng worker thread.
- NIO (Non blocking) được thiết kế để tăng throughput nếu application call ra bên ngoài nhiều, trong trường hợp phải chạy thuật toán nặng, cho phép chọn lựa thread đặc thù để chạy, tránh ảnh hưởng các thread chuyên dùng xử lý yêu cầu nhanh, gọn

#### 3.2.2 Phong cách Single thread Nodejs
- Vì chỉ có 1 thread nhận toàn bộ request, nên trong Nodejs sẽ có event queue
- 1 request đến và yêu cầu data từ bên ngoài thì: Hoặc cho OS xử lý (database, network) rồi signal cho event loop thread, hoặc cho internal worker thread xử lý rồi add call back vào queue
- Cần khởi tạo 1 worker thread riêng biệt nếu như task yêu cầu dùng CPU nhiều
- 1 single event loop thread trên NodeJs không bao giờ bị block nên có thể đáp ứng nhiều request cùng lúc. Giống như đầu bếp chỉ quan tâm ướp gà và chỉ ướp gà, những công đoạn sau không cần để ý những công đoạn khác

#### 3.2.3 Phong cách Spring WebFlux(Reactive)
- Về mặt vật lý, xử lý data thì căn bản giống như trên nhưng điểm khác nhau về programing model và số lượng event loop threads
- Ở Nodejs có thể hiểu event loop như 1 manager điều phối request và trả về response khi có sự kiện. Có thể hiểu, sau khi đầu bếp đưa gà ra quầy thì manager sẽ biết cần đưa con gà này cho ai
- Spring WebFlux thì dùng Netty engine, thay vì 1 manager thì nhiều manager. Ví dụ: Manager A phục vụ bàn từ 1 tới 10, B thì 11 tới 20. Và thường thì số event loop thead = 2 * core.
- Khác biệt lớn nhất là về tư duy code: Nodejs callback regisration, WebFlux subscription chain

#### 3.2.4 Phong cách State Machine


## 4. Có phải NonBlocking luôn tốt
Như có đề cập ở trên, NonBlocking chỉ tốt nếu như application đòi hỏi IO nhiều, vì IO nhiều sẽ được OS/kernel quản lý thông qua socket, mỗi khi có data thì socket sẽ báo kernel, kernel notify thread, lúc đó thread mới làm việc.
Trong trạng thái chờ IO data, thread về pool để làm việc khác, đó là lý do khả năng thoughput của NIO application vượt tra application truyền thống.
Nhưng khi applicaton yêu cầu xử lý CPU nặng như: Đào coin, thuật toán, tạo ảnh/video. NIO không còn ý nghĩa và còn làm chậm hơn so với web app thông thường, vì việc đánh thức và thay đổi trạng thái sẽ tốn chi phí: Chuyển đổi ngữ cảnh

